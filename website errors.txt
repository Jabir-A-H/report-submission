sqlalchemy.exc.InvalidRequestError
sqlalchemy.exc.InvalidRequestError: One or more mappers failed to initialize - can't proceed with initialization of other mappers. Triggering mapper: 'Mapper[Zone(zone)]'. Original exception was: Could not determine join condition between parent/child tables on relationship Zone.users - there are no foreign keys linking these tables.  Ensure that referencing columns are associated with a ForeignKey or ForeignKeyConstraint, or specify a 'primaryjoin' expression.

Traceback (most recent call last)
File "F:\WebDev\report-submission\venv\Lib\site-packages\flask\app.py", line 1536, in __call__
    ) -> cabc.Iterable[bytes]:
        """The WSGI server calls the Flask application object as the
        WSGI application. This calls :meth:`wsgi_app`, which can be
        wrapped to apply middleware.
        """
        return self.wsgi_app(environ, start_response)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
File "F:\WebDev\report-submission\venv\Lib\site-packages\flask\app.py", line 1514, in wsgi_app
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
                           ^^^^^^^^^^^^^^^^^^^^^^^^
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
File "F:\WebDev\report-submission\venv\Lib\site-packages\flask\app.py", line 1511, in wsgi_app
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
File "F:\WebDev\report-submission\venv\Lib\site-packages\flask\app.py", line 919, in full_dispatch_request
            request_started.send(self, _async_wrapper=self.ensure_sync)
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
        except Exception as e:
            rv = self.handle_user_exception(e)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        return self.finalize_request(rv)
 
    def finalize_request(
        self,
        rv: ft.ResponseReturnValue | HTTPException,
File "F:\WebDev\report-submission\venv\Lib\site-packages\flask\app.py", line 917, in full_dispatch_request
 
        try:
            request_started.send(self, _async_wrapper=self.ensure_sync)
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
                     ^^^^^^^^^^^^^^^^^^^^^^^
        except Exception as e:
            rv = self.handle_user_exception(e)
        return self.finalize_request(rv)
 
    def finalize_request(
File "F:\WebDev\report-submission\venv\Lib\site-packages\flask\app.py", line 902, in dispatch_request
            and req.method == "OPTIONS"
        ):
            return self.make_default_options_response()
        # otherwise dispatch to the handler for that endpoint
        view_args: dict[str, t.Any] = req.view_args  # type: ignore[assignment]
        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
    def full_dispatch_request(self) -> Response:
        """Dispatches the request and on top of that performs request
        pre and postprocessing as well as HTTP exception catching and
        error handling.
File "F:\WebDev\report-submission\venv\Lib\site-packages\flask_login\utils.py", line 284, in decorated_view
 
    @wraps(func)
    def decorated_view(*args, **kwargs):
        if request.method in EXEMPT_METHODS or current_app.config.get("LOGIN_DISABLED"):
            pass
        elif not current_user.is_authenticated:
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            return current_app.login_manager.unauthorized()
 
        # flask 1.x compatibility
        # current_app.ensure_sync is only available in Flask >= 2.0
        if callable(getattr(current_app, "ensure_sync", None)):
File "F:\WebDev\report-submission\venv\Lib\site-packages\werkzeug\local.py", line 318, in __get__
                return self.class_value
 
            return self
 
        try:
            obj = instance._get_current_object()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        except RuntimeError:
            if self.fallback is None:
                raise
 
            fallback = self.fallback.__get__(instance, owner)
File "F:\WebDev\report-submission\venv\Lib\site-packages\werkzeug\local.py", line 526, in _get_current_object
                return get_name(obj)
 
        elif callable(local):
 
            def _get_current_object() -> T:
                return get_name(local())
                                ^^^^^^^
 
        else:
            raise TypeError(f"Don't know how to proxy '{type(local)}'.")
 
        object.__setattr__(self, "_LocalProxy__wrapped", local)
File "F:\WebDev\report-submission\venv\Lib\site-packages\flask_login\utils.py", line 25, in <lambda>
from .signals import user_logged_out
from .signals import user_login_confirmed
 
#: A proxy for the current user. If no user is logged in, this will be an
#: anonymous user
current_user = LocalProxy(lambda: _get_user())
                                  ^^^^^^^^^^^
 
 
def encode_cookie(payload, key=None):
    """
    This will encode a ``str`` value into a cookie, and sign that cookie
File "F:\WebDev\report-submission\venv\Lib\site-packages\flask_login\utils.py", line 370, in _get_user
 
 
def _get_user():
    if has_request_context():
        if "_login_user" not in g:
            current_app.login_manager._load_user()
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
        return g._login_user
 
    return None
 
File "F:\WebDev\report-submission\venv\Lib\site-packages\flask_login\login_manager.py", line 364, in _load_user
        user = None
 
        # Load user from Flask Session
        user_id = session.get("_user_id")
        if user_id is not None and self._user_callback is not None:
            user = self._user_callback(user_id)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
        # Load user from Remember Me Cookie or Request Loader
        if user is None:
            config = current_app.config
            cookie_name = config.get("REMEMBER_COOKIE_NAME", COOKIE_NAME)
File "F:\WebDev\report-submission\app.py", line 182, in load_user
# --- Login Manager ---
 
 
@login_manager.user_loader  # type: ignore
def load_user(user_id):  # type: ignore
    return User.query.get(int(user_id))  # type: ignore
           ^^^^^^^^^^
 
 
# --- Utility Functions ---
 
 
File "F:\WebDev\report-submission\venv\Lib\site-packages\flask_sqlalchemy\model.py", line 22, in __get__
 
    :meta private:
    """
 
    def __get__(self, obj: Model | None, cls: type[Model]) -> Query:
        return cls.query_class(
               
            cls, session=cls.__fsa__.session()  # type: ignore[arg-type]
        )
 
 
class Model:
File "F:\WebDev\report-submission\venv\Lib\site-packages\sqlalchemy\orm\query.py", line 276, in __init__
        # where it stores a Query without a Session and also there are tests
        # for the query(Entity).with_session(session) API which is likely in
        # some old recipes, however these are legacy as select() can now be
        # used.
        self.session = session  # type: ignore
        self._set_entities(entities)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
    def _set_propagate_attrs(self, values: Mapping[str, Any]) -> Self:
        self._propagate_attrs = util.immutabledict(values)
        return self
 
File "F:\WebDev\report-submission\venv\Lib\site-packages\sqlalchemy\orm\query.py", line 289, in _set_entities
        entities: Union[
            _ColumnsClauseArgument[Any], Iterable[_ColumnsClauseArgument[Any]]
        ],
    ) -> None:
        self._raw_columns = [
            coercions.expect(
            ^
                roles.ColumnsClauseRole,
                ent,
                apply_propagate_attrs=self,
                post_inspect=True,
            )
File "F:\WebDev\report-submission\venv\Lib\site-packages\sqlalchemy\sql\coercions.py", line 388, in expect
            if not is_clause_element:
                if impl._use_inspection and not disable_inspection:
                    insp = inspection.inspect(element, raiseerr=False)
                    if insp is not None:
                        if post_inspect:
                            insp._post_inspect
                            ^^^^^^^^^^^^^^^^^^
                        try:
                            resolved = insp.__clause_element__()
                        except AttributeError:
                            impl._raise_for_expected(original_element, argname)
 
File "F:\WebDev\report-submission\venv\Lib\site-packages\sqlalchemy\util\langhelpers.py", line 1338, in __get__
        def __get__(self, obj: Any, cls: Any) -> _T: ...
 
        def __get__(self, obj, cls):
            if obj is None:
                return self
            obj.__dict__[self.__name__] = result = self.fget(obj)
                                                   ^^^^^^^^^^^^^^
            obj._memoized_keys |= {self.__name__}
            return result
 
    @classmethod
    def memoized_instancemethod(cls, fn: _F) -> _F:
File "F:\WebDev\report-submission\venv\Lib\site-packages\sqlalchemy\orm\mapper.py", line 2724, in _post_inspect
            coercions.expect(roles.ColumnsClauseRole, ent, keep_inspect=True)
 
        This allows the inspection process run a configure mappers hook.
 
        """
        self._check_configure()
        ^^^^^^^^^^^^^^^^^^^^^^^
 
    @HasMemoized_ro_memoized_attribute
    def _with_polymorphic_selectable(self) -> FromClause:
        if not self.with_polymorphic:
            return self.persist_selectable
File "F:\WebDev\report-submission\venv\Lib\site-packages\sqlalchemy\orm\mapper.py", line 2401, in _check_configure
        "operation.",
        sa_exc.SAWarning,
    )
    def _check_configure(self) -> None:
        if self.registry._new_mappers:
            _configure_registries({self.registry}, cascade=True)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
    def _post_configure_properties(self) -> None:
        """Call the ``init()`` method on all ``MapperProperties``
        attached to this mapper.
 
File "F:\WebDev\report-submission\venv\Lib\site-packages\sqlalchemy\orm\mapper.py", line 4214, in _configure_registries
            # initialize properties on all mappers
            # note that _mapper_registry is unordered, which
            # may randomly conceal/reveal issues related to
            # the order of mapper compilation
 
            _do_configure_registries(registries, cascade)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        finally:
            _already_compiling = False
    Mapper.dispatch._for_class(Mapper).after_configured()  # type: ignore
 
 
File "F:\WebDev\report-submission\venv\Lib\site-packages\sqlalchemy\orm\mapper.py", line 4251, in _do_configure_registries
                    "mappers. Triggering mapper: '%s'. "
                    "Original exception was: %s"
                    % (mapper, mapper._configure_failed)
                )
                e._configure_failed = mapper._configure_failed  # type: ignore
                raise e
                ^^^^^^^
 
            if not mapper.configured:
                try:
                    mapper._post_configure_properties()
                    mapper._expire_memoizations()
sqlalchemy.exc.InvalidRequestError: One or more mappers failed to initialize - can't proceed with initialization of other mappers. Triggering mapper: 'Mapper[Zone(zone)]'. Original exception was: Could not determine join condition between parent/child tables on relationship Zone.users - there are no foreign keys linking these tables. Ensure that referencing columns are associated with a ForeignKey or ForeignKeyConstraint, or specify a 'primaryjoin' expression.
The debugger caught an exception in your WSGI application. You can now look at the traceback which led to the error.
To switch between the interactive traceback and the plaintext one, you can click on the "Traceback" headline. From the text traceback you can also create a paste of it. For code execution mouse-over the frame you want to debug and click on the console icon on the right side.

You can execute arbitrary Python code in the stack frames and there are some extra helpers available for introspection:

dump() shows all variables in the frame
dump(obj) dumps all that's known about the object
Brought to you by DON'T PANIC, your friendly Werkzeug powered traceback interpreter.